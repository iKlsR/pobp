{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"personal opengl boilerplate using GLFW, GLEW, GLM and SOIL with helper functions","body":"This project uses:\r\n\r\n[GLFW](http://glfw.org)\r\n\r\n[GLEW](http://glew.sourceforge.net)\r\n\r\n[SOIL](http://http://lonesock.net/soil.html)\r\n\r\n[GLM](http://glm.g-truc.net/)\r\n\r\n# _Functions_\r\n\r\n## **buffer.hpp**\r\n\r\n`obp_make_vao();`\r\n* takes no paramters but returns a unique vertex array id.\r\n\r\n`obp_make_buffer(GLenum target, GLsizei buffer_size, const void * buffer_data);`\r\n* takes the target BUFFER, buffer size and the buffer data(ie the vertices, indices etc) and returns a unique buffer id\r\n\r\n`obp_make_frame_buffer(void)`\r\n* returns a unique frame buffer id\r\n\r\n`obp_make_render_buffer(void)`\r\n* return a unique render buffer id\r\n\r\n`obp_bind_buffer(GLenum target, GLuint buffer);`\r\n* takes the buffer to rebind and its target BUFFER(used when drawing multiple meshes, models etc) and returns said buffer\r\n\r\n`obp_bind_vao(GLuint vao)`\r\n* takes the vertex array to rebind(ideal for multiple shaders)\r\n\r\n`void obp_delete_vao(GLuint vao)`\r\n* deletes the vertex array passed into it\r\n\r\n`void obp_delete_buffer(GLuint buffer)`\r\n* deletes the buffer passed into it, might do well to obp_bind_buffer(0, target_buffer) too\r\n\r\n`void obp_disable_vertex_attrib(GLint attrib)`\r\n* disables the vertex attrib array passed into it\r\n\r\n## **events.hpp**\r\n\r\n`GLFWCALL void obp_window_size_callback(int width, int height)`\r\n* window callback funtion, also handles the aspect ratio of the window\r\n\r\n`GLFWCALL int obp_window_close_callback(void)`\r\n* invokes the default window close (when user clicks the x)\r\n\r\n`GLFWCALL void obp_event_key_callback(int key, int action)`\r\n* _main_ key callback funtion(however, key presses can still be captured anywhere in the code)\r\n\r\n`GLFWCALL void obp_event_mouse_callback(int character, int action)`\r\n* _main_ mouse callback funtion(however, the mouse can still be captured anywhere in the code)\r\n\r\n`void obp_callbacks(bool key, bool mouse)`\r\n* _master_ callback function, used at runtime to enable/disable the keyboard or mouse\r\n\r\n## **common.hpp**\r\n\r\n`obp_gl_info(void)`\r\n* returns graphics vendor, opengl major and minor version, glsl version and number of processors(thanks glfw)\r\n\r\n## **contio.hpp**\r\n\r\n`getViewMatrix()`\r\n* gets the view matrix of the current camera type and returns it\r\n\r\n`getProjectionMatrix()`\r\n* gets the projection matrix of the current camera type and returns it\r\n\r\n`obp_fps()`\r\n* creates a free moving fps style camera that can be used to navigate the scene, use mousewheel to adjust FoV, WASD to accelerate, decelerate and strafe, mouse to change direction\r\n\r\n`obp_trackball_rot()`\r\n* creates a 3d software type camera that looks at the object and rotates around it(axis locks at top and bottom)\r\n\r\n`obp_accurate_3d()`\r\n* creates a 3d software type camera that looks at the object in straight orthogonal directions, top, bottom, left, right etc [WIP]\r\n\r\n`obp_camera_type()`\r\n* _master_ function of the header that is used to choose what camera type to use at runtime(this is the function to use in the mainloop)\r\n\r\n## **loader.hpp**\r\n\r\n`obp_load_image(const char * file_path, GLenum active_texture)`\r\n* accepts the path to _any_ valid image file and the active texture to map it to, returns the image after it has been binded and doctored\r\n\r\n`obp_load_shaders_ff(const char * vertex_file_path, const char * fragment_file_path)`\r\n* loads a vertex and fragment shader from (a) file(s) and doctors them, returns a shader program and also does error checking\r\n\r\n`obp_load_shaders_fm(const char * vertex_file_path, const char * fragment_file_path)`\r\n* loads a vertex and fragment shader from memory(a const GLchar var) and doctors them, returns a shader program and also does error checking\r\n\r\n`obp_load_cmap (const char * xpos, const char * xneg, const char * ypos, const char * yneg, const char * zpos, const char * zneg, GLenum active_texture)`\r\n* takes a cubemap sliced into 6 images and the active texture slot to map it to\r\n\r\n`obp_load_obj(const char * path, vector<vec3> & out_vertices, vector<vec2> & out_uvs, vector<vec3> & out_normals)`\r\n* simple .obj parser, accepts a path and 3 holder variables, it returns the values back to the function parameters, also does a little smart checking[WIP]\r\n\r\n### _Miscellaneous_\r\n\r\nConcerned about memory management pertaining images and shaders? see `loader.hpp`, any resources allocated are destroyed after. Only buffers and vertex code etc have to be manually destroyed.. this allows for a bit more freedom. pobp is optimized and 100% memory efficient.","name":"popb","google":""}